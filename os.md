## 基础

### 内核（kernel）

控制计算机硬件资源，提供程序运行环境。

### 系统调用（system call）

- 内核接口，由此程序向内核请求服务。公用函数库建在系统调用之上，应用程序既可使用公用函数库，也可使用系统调用。
- 从实现者角度，系统调用和库函数有根本的区别。从用户角度，其区别并不重要。
  - 系统调用通常提供一种最小接口，而库函数通常提供比较复杂的功能。

### 程序（program）

一个存储在磁盘某个目录中的可执行文件。内核使用 exec 函数将程序读入内存，并执行程序。

### 进程（process）

- 程序的执行实例。
- 每个进程都有一个唯一的数字标识，进程 ID（process ID），总是一个非负整数

## Unix 标准及其实现

- ISO C
- POSIX: 可移植操作系统接口（Portable Operating System Interface）
- GNU/Linux

## 文件 I/O

- 对内核而言，所有打开的文件都用文件描述符引用。文件描述符是一个非负整数。当打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。当读、写一个文件时，使用 open 或 create 返回的文件描述符标识该文件，将其作为参数传给 read 或 write。
- 文件描述符惯例
  - STDIN_FILENO：0 // 进程的标准输入
  - STDOUT_FILENO：1 // 进程的标准出
  - STDERR_FILENO：2 // 进程的标准错误
- open/create
  - 打开或创建一个文件
- read
- write
- lseek
- close
  - 关闭一个打开文件

## 文件和目录

- 文件类型
  - 普通文件（regular file）。包含某种形式的数据。文本或二进制对于内核并无区别，由处理该文件的应用程序进行解释。
  - 目录文件（directory file）。包含其他文件的名字和指针。有读权限的进程可以读该目录的内容，但只有内核可以直接写。
  - 块特殊文件（block special file）。提供对设备（如磁盘）带缓冲的访问，每次访问以固定长度为单位进行。FreeBSD 不再支持。
  - 字符特殊文件（character special file）。提供对设备不带缓冲的访问，访问长度可变。系统中所有设备要么是字符特殊文件，要么是块特殊文件。
  - FIFO。用于进程间通信（IPC）。也成为命名管道（named pipe）。
  - 套接字（socket）。用于进程间通信。
  - 符号链接（symbol link）。指向另一个文件。

## 进程

- C 程序存储空间布局
  - 正文段。机器指令。通常可共享、只读。// \_\_TEXT
  - 数据段。程序中需要明确赋初值的变量。// \_\_DATA
  - 栈。自动变量以及每次函数调用需要保存的信息（返回地址、调用者环境信息）。然后，最近被调用的函数在栈上为其自动和临时变量分配存储空间。
  - 堆。动态存储分配。
- 共享库
  - 使得可执行文件不再需要包含公用的库函数，而只需在所有进程可以引用的存储区种保存这个库例程的一个副本。
  - 程序第一次执行或者第一次调用某个库函数时，用动态链接方法将程序与共享库函数链接。
  - 减少了每个可执行文件的长度，增加了一些运行时间开销。开销发生在程序第一次被执行或者每个共享库函数第一次被调用时。
  - 另一个优点是可以用库函数的新版本代替老版本而无需对使用该库的程序重新连接编辑。
- 存储空间分配
  - malloc
  - free
- 环境变量
  - name=value
  - 内核不查看这些字符串，解释完全取决于各个应用程序
- fork
  - 创建一个新进程。由 fork 创建的新进程被称为子进程（child process）。fork 函数被调用一次，但返回两次。两次返回的区别是子进程的返回值是 0，父进程的返回值是新建子进程的进程 ID。
- exec

## 信号（signal）

- 软件中断，提供了一种处理异步事件的方法。用于通知进程发生了某种情况，产生信号的事件对进程而言是随机的，可以告诉内核“在此信号发生时，请执行下列操作”。例如：
  - 终端按键引发
  - 硬件异常，除数为 0，无效/非法内存引用
  - 软件条件发生
  - kill
- 向一个进程发送信号时，必须使进程所有者或者超级用户。
- 进程处理信号方式：
  - 忽略。大多数可以忽略，但 SIGKILL 和 SIGSTOP 向内核和超级用户提供了终止或停止进程的可靠方法，不能忽略。某些硬件异常信号后果不确定，不推荐。
  - 捕捉信号。提供信号处理函数，按照期望的方式处理。不能捕捉 SIGKILL 和 SIGSTOP 信号。
  - 系统默认方式处理。对于大多数信号系统默认操作是终止该进程。

### 线程（thread）

- 线程在单进程环境中执行多个任务。通常一个进程只有一个控制线程——某一时刻执行的一组机器指令。对于某些问题，如果有多个控制线程分别作用于它的不同部分，那么解决起来就容易得多。也可以充分利用多处理器的并行能力。
  - 通过为每类事件类型分配单独的处理线程，可以简化处理异步事件的代码。每个线程在进行事件处理时可以采用同步编程模式，更加简单。
  - 一个进程内的所有线程共享同一地址空间、文件描述符、栈以及与进程相关的属性。因为他们能访问同一存储区，所以各线程在访问共享数据时需要采取同步措施以避免不一致性。
  - 有些问题可以分解从而提高整个程序吞吐量。
  - 交互程序也可以通过多线程来改善响应时间，可以把处理用户输入输出的部分与其他部分分开。
  - 处理器数量不影响程序结构，即使运行在单处理器上，也能得到多线程编程的好处。某些线程阻塞时候，另外一些线程依然可以运行。
  - 每个线程都包含表示执行环境所必须的信息，包括线程 ID、一组寄存器值、栈、调度优先级和策略、信号屏蔽字、errno 变量以及线程私有数据。
  - 一个进程的所有信息对该进程的所有线程都是共享的，包括可执行程序的代码、程序的全局内存和堆内存、栈以及文件描述符。
- 线程也用 ID（thread ID）标识，但只在它所属的进程内起作用。
- 线程同步
  - 当多个线程共享相同的内存时，需要确保每个线程看到一致的数据视图。当一个线程可以修改的变量，其他线程也可以读写的时候，我们就需要对这些线程进行同步，确保它们在访问变量存储内容时候不会访问到无效的值。
  - 在变量修改时间多于一个存储器访问周期的处理器结构中，当存储器读和写两个周期交叉时，这种不一致就会出现。与处理器体系结构相关，可移植程序不能对此做任何假设。
  - 线程使用锁，同一时间只允许一个线程访问该变量。
- 互斥量（mutex）
  - 从本质上是一把锁，在访问共享资源前对互斥量进行设置（加锁），在访问完成后释放（解锁）。对互斥量加锁后，任何其他试图再次加锁的线程都会被阻塞，直到当前线程释放。如果释放时有一个以上的线程阻塞，那么所有该锁上的线程都会变成可运行状态，第一个变为运行的线程就可以对互斥量加锁，其他线程就会看到互斥量依然是锁着的，只能回去再次等待它重新变为可用。在这种方式下，每次只有一个线程可以向前执行。
- 避免死锁（deadlock）
  - 如果线程试图对同一个互斥量加锁两次，它自身就会陷入死锁状态。
  - 程序中使用一个以上的互斥量时，如果允许一个线程一直占有第一个互斥量，并且在试图锁住第二个互斥量时处于阻塞状态，但是拥有第二个互斥量的线程也在试图锁住第一个互斥量。因为两个线程都在相互请求另一个线程拥有的资源，所以都无法向前运行，产生死锁。
  - 可以通过仔细控制互斥量加锁的顺序来避免死锁发生。比如所有线程总是在对互斥量 B 加锁前锁住互斥量 A。
  - 有时，应用程序的结构使得对互斥量进行排序很困难。这种情况下，可以先释放占有的锁，做好清理工作，过段时间再试。
- 读写锁（reader-writer lock）
  - 与互斥量类似，但允许更高的并行性。互斥量要么是锁住状态，要么是不加锁状态，一次只有一个线程对其加锁。读写锁可以有三种状态：读模式下加锁，写模式下加锁，不加锁。一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁。
  - 当读写锁在读加锁状态时，所有试图以读模式对它进行加锁的线程都可以得到访问权，但任何希望以写模式加锁的线程都会阻塞，直到所有线程释放它们的读锁位置。
  - 当读写锁处于读模式锁住状态，这时有一个线程试图以写模式获取锁时，读写锁通常会阻塞随后的读模式锁请求。这样可以避免读模式锁长期占用，而等待的写模式锁请求一直得不到满足。
  - 非常适合对数据结构读的次数远大于写的情况。
  - 也叫共享互斥锁（shared-exclusive clock)。读模式锁住时，是共享模式锁住的；写模式锁住时，是互斥模式锁住的。
  - 与互斥量一样，系统提供带有超时的读写锁，使应用程序在获取读写锁时避免陷入永久阻塞状态。

## 参考书目和文献

- W.Richard Stevens, Stephen A. Rago. Advanced Programming in the Unix Environment. 3rd Edition. 2013. 戚正伟, 张亚英, 尤晋元 译. 人民邮电出版社, 2014.
